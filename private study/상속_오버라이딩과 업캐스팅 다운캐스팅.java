package jump;
	
public class SuperEx {
	
	public static void main(String[] args) {
	A b = new B();
	
	b.paint();
	b.draw();
}
}

class A{
	public void paint() {
		System.out.print("A");
		draw();
	}
	
	public void draw()  {
		System.out.print("B");
		draw();
	}
class B extends A{ 
	public void paint() {
		super.draw();
		System.out.print("C");
		this.draw();
	}
	public void draw() {
		System.out.print("D");
	}
}
	
}
/*instanceof 연산자 : 업캐스팅 받은 레퍼런스가 누구의 객체인지 구분하기 위헤 사용한다*/ 
//동적 바인딩은 런타임시 정해진다

//업캐스팅은 서브클랙스 객체에 대한 값을 슈퍼 클래스 타입으로 변환하는 것 
//업캐스팅은 슈퍼클래스의 레퍼런스로 서브 클래스의 객체를 가리키게 한다

//부모의 형태에 변수를 선언하고 자식의 생성자를 넣는 것

//mom M = new child(); (예시)

/*업캐스팅 원칙
1.자식에 이름이 같은 메서드가 있으면 우선 작동한다 ( 오버라이딩)

2.자식에 super()가 있으면 부모의 그것을 호출한다

3.부모에 자식과 같은 메소드가 있으면 , 자식을 호출한다(오버라이딩)

다운캐스팅은 자식 타입으로 객체를 만들고 부모 타입에 대입

부모타입을 갖은 객체는 부모 타입만 접근 가능 
*/

/*메소드 오버라이딩은 슈퍼클래스와 서브클래스ㅇ의 메소드 관계에서, 슈퍼클래스에 선언된 메소드와 같은 이름 같은 리턴 타입 같은 매개 변수 리스트 등을 갖는 메소드를
 서브 클래스에서 재작성 하는 것이다.
 슈퍼클래스
 메소드1()
 메소드2()
 메소드3() 
 
 서브 클래스
 메소드2() 동적 할당이기에 런타임 단계에서 할당됨
  
  위와 같은 상황에서 외부에서나 내부에서 메소드2()를 호출하면 슈퍼클래스의 메소드는 절대로 실행되지않고 반드시 서브 클래스의 메소드2()가 실행된다
 	메소드 오버라이딩은 슈퍼클래스 메소드 무시하기
 
 메소드 오버라이딩 규칙: 슈퍼클래스 메소드와동일한 원형일 것, 접근 범위를 좁혀서 오버라이딩 할 수 없다.  static private final 로 선언된 메소드는 서브 클래스에서 오바리이딩 할 수 없다.
 
 오버리이딩은 서브 클래스의 목적에 맞게 사용한다.
 
 
 */


